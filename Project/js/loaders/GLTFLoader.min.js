!(function () {
  function e() {
    let e = {};
    return {
      get: function (t) {
        return e[t];
      },
      add: function (t, s) {
        e[t] = s;
      },
      remove: function (t) {
        delete e[t];
      },
      removeAll: function () {
        e = {};
      },
    };
  }
  const t = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
      "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  };
  class s {
    constructor(e) {
      (this.parser = e),
        (this.name = t.KHR_LIGHTS_PUNCTUAL),
        (this.cache = { refs: {}, uses: {} });
    }
    _markDefs() {
      const e = this.parser,
        t = this.parser.json.nodes || [];
      for (let s = 0, n = t.length; s < n; s++) {
        const n = t[s];
        n.extensions &&
          n.extensions[this.name] &&
          void 0 !== n.extensions[this.name].light &&
          e._addNodeRef(this.cache, n.extensions[this.name].light);
      }
    }
    _loadLight(e) {
      const t = this.parser,
        s = "light:" + e;
      let n = t.cache.get(s);
      if (n) return n;
      const r = t.json,
        o = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[e];
      let i;
      const a = new THREE.Color(16777215);
      void 0 !== o.color && a.fromArray(o.color);
      const l = void 0 !== o.range ? o.range : 0;
      switch (o.type) {
        case "directional":
          (i = new THREE.DirectionalLight(a)).target.position.set(0, 0, -1),
            i.add(i.target);
          break;
        case "point":
          (i = new THREE.PointLight(a)).distance = l;
          break;
        case "spot":
          ((i = new THREE.SpotLight(a)).distance = l),
            (o.spot = o.spot || {}),
            (o.spot.innerConeAngle =
              void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0),
            (o.spot.outerConeAngle =
              void 0 !== o.spot.outerConeAngle
                ? o.spot.outerConeAngle
                : Math.PI / 4),
            (i.angle = o.spot.outerConeAngle),
            (i.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle),
            i.target.position.set(0, 0, -1),
            i.add(i.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type);
      }
      return (
        i.position.set(0, 0, 0),
        (i.decay = 2),
        void 0 !== o.intensity && (i.intensity = o.intensity),
        (i.name = t.createUniqueName(o.name || "light_" + e)),
        (n = Promise.resolve(i)),
        t.cache.add(s, n),
        n
      );
    }
    createNodeAttachment(e) {
      const t = this,
        s = this.parser,
        n = s.json.nodes[e],
        r = ((n.extensions && n.extensions[this.name]) || {}).light;
      return void 0 === r
        ? null
        : this._loadLight(r).then(function (e) {
            return s._getNodeRef(t.cache, r, e);
          });
    }
  }
  class n {
    constructor() {
      this.name = t.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return THREE.MeshBasicMaterial;
    }
    extendParams(e, t, s) {
      const n = [];
      (e.color = new THREE.Color(1, 1, 1)), (e.opacity = 1);
      const r = t.pbrMetallicRoughness;
      if (r) {
        if (Array.isArray(r.baseColorFactor)) {
          const t = r.baseColorFactor;
          e.color.fromArray(t), (e.opacity = t[3]);
        }
        void 0 !== r.baseColorTexture &&
          n.push(
            s.assignTexture(e, "map", r.baseColorTexture, THREE.sRGBEncoding)
          );
      }
      return Promise.all(n);
    }
  }
  class r {
    constructor(e) {
      (this.parser = e), (this.name = t.KHR_MATERIALS_CLEARCOAT);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name]
        ? THREE.MeshPhysicalMaterial
        : null;
    }
    extendMaterialParams(e, t) {
      const s = this.parser,
        n = s.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = [],
        o = n.extensions[this.name];
      if (
        (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor),
        void 0 !== o.clearcoatTexture &&
          r.push(s.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        void 0 !== o.clearcoatRoughnessFactor &&
          (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        void 0 !== o.clearcoatRoughnessTexture &&
          r.push(
            s.assignTexture(
              t,
              "clearcoatRoughnessMap",
              o.clearcoatRoughnessTexture
            )
          ),
        void 0 !== o.clearcoatNormalTexture &&
          (r.push(
            s.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
          ),
          void 0 !== o.clearcoatNormalTexture.scale))
      ) {
        const e = o.clearcoatNormalTexture.scale;
        t.clearcoatNormalScale = new THREE.Vector2(e, e);
      }
      return Promise.all(r);
    }
  }
  class o {
    constructor(e) {
      (this.parser = e), (this.name = t.KHR_MATERIALS_SHEEN);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name]
        ? THREE.MeshPhysicalMaterial
        : null;
    }
    extendMaterialParams(e, t) {
      const s = this.parser,
        n = s.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = [];
      (t.sheenColor = new THREE.Color(0, 0, 0)),
        (t.sheenRoughness = 0),
        (t.sheen = 1);
      const o = n.extensions[this.name];
      return (
        void 0 !== o.sheenColorFactor &&
          t.sheenColor.fromArray(o.sheenColorFactor),
        void 0 !== o.sheenRoughnessFactor &&
          (t.sheenRoughness = o.sheenRoughnessFactor),
        void 0 !== o.sheenColorTexture &&
          r.push(
            s.assignTexture(
              t,
              "sheenColorMap",
              o.sheenColorTexture,
              THREE.sRGBEncoding
            )
          ),
        void 0 !== o.sheenRoughnessTexture &&
          r.push(
            s.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
          ),
        Promise.all(r)
      );
    }
  }
  class i {
    constructor(e) {
      (this.parser = e), (this.name = t.KHR_MATERIALS_TRANSMISSION);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name]
        ? THREE.MeshPhysicalMaterial
        : null;
    }
    extendMaterialParams(e, t) {
      const s = this.parser,
        n = s.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = [],
        o = n.extensions[this.name];
      return (
        void 0 !== o.transmissionFactor &&
          (t.transmission = o.transmissionFactor),
        void 0 !== o.transmissionTexture &&
          r.push(s.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(r)
      );
    }
  }
  class a {
    constructor(e) {
      (this.parser = e), (this.name = t.KHR_MATERIALS_VOLUME);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name]
        ? THREE.MeshPhysicalMaterial
        : null;
    }
    extendMaterialParams(e, t) {
      const s = this.parser,
        n = s.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = [],
        o = n.extensions[this.name];
      (t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0),
        void 0 !== o.thicknessTexture &&
          r.push(s.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        (t.attenuationDistance = o.attenuationDistance || 0);
      const i = o.attenuationColor || [1, 1, 1];
      return (
        (t.attenuationColor = new THREE.Color(i[0], i[1], i[2])), Promise.all(r)
      );
    }
  }
  class l {
    constructor(e) {
      (this.parser = e), (this.name = t.KHR_MATERIALS_IOR);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name]
        ? THREE.MeshPhysicalMaterial
        : null;
    }
    extendMaterialParams(e, t) {
      const s = this.parser.json.materials[e];
      if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
      const n = s.extensions[this.name];
      return (t.ior = void 0 !== n.ior ? n.ior : 1.5), Promise.resolve();
    }
  }
  class c {
    constructor(e) {
      (this.parser = e), (this.name = t.KHR_MATERIALS_SPECULAR);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name]
        ? THREE.MeshPhysicalMaterial
        : null;
    }
    extendMaterialParams(e, t) {
      const s = this.parser,
        n = s.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const r = [],
        o = n.extensions[this.name];
      (t.specularIntensity =
        void 0 !== o.specularFactor ? o.specularFactor : 1),
        void 0 !== o.specularTexture &&
          r.push(s.assignTexture(t, "specularIntensityMap", o.specularTexture));
      const i = o.specularColorFactor || [1, 1, 1];
      return (
        (t.specularColor = new THREE.Color(i[0], i[1], i[2])),
        void 0 !== o.specularColorTexture &&
          r.push(
            s.assignTexture(
              t,
              "specularColorMap",
              o.specularColorTexture,
              THREE.sRGBEncoding
            )
          ),
        Promise.all(r)
      );
    }
  }
  class u {
    constructor(e) {
      (this.parser = e), (this.name = t.KHR_TEXTURE_BASISU);
    }
    loadTexture(e) {
      const t = this.parser,
        s = t.json,
        n = s.textures[e];
      if (!n.extensions || !n.extensions[this.name]) return null;
      const r = n.extensions[this.name],
        o = t.options.ktx2Loader;
      if (!o) {
        if (
          s.extensionsRequired &&
          s.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
          );
        return null;
      }
      return t.loadTextureImage(e, r.source, o);
    }
  }
  class h {
    constructor(e) {
      (this.parser = e),
        (this.name = t.EXT_TEXTURE_WEBP),
        (this.isSupported = null);
    }
    loadTexture(e) {
      const t = this.name,
        s = this.parser,
        n = s.json,
        r = n.textures[e];
      if (!r.extensions || !r.extensions[t]) return null;
      const o = r.extensions[t],
        i = n.images[o.source];
      let a = s.textureLoader;
      if (i.uri) {
        const e = s.options.manager.getHandler(i.uri);
        null !== e && (a = e);
      }
      return this.detectSupport().then(function (r) {
        if (r) return s.loadTextureImage(e, i, a);
        if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
          throw new Error(
            "THREE.GLTFLoader: WebP required by asset but unsupported."
          );
        return s.loadTexture(e);
      });
    }
    detectSupport() {
      return (
        this.isSupported ||
          (this.isSupported = new Promise(function (e) {
            const t = new Image();
            (t.src =
              "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
              (t.onload = t.onerror =
                function () {
                  e(1 === t.height);
                });
          })),
        this.isSupported
      );
    }
  }
  class p {
    constructor(e) {
      (this.name = t.EXT_MESHOPT_COMPRESSION), (this.parser = e);
    }
    loadBufferView(e) {
      const t = this.parser.json,
        s = t.bufferViews[e];
      if (s.extensions && s.extensions[this.name]) {
        const e = s.extensions[this.name],
          n = this.parser.getDependency("buffer", e.buffer),
          r = this.parser.options.meshoptDecoder;
        if (!r || !r.supported) {
          if (
            t.extensionsRequired &&
            t.extensionsRequired.indexOf(this.name) >= 0
          )
            throw new Error(
              "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
            );
          return null;
        }
        return Promise.all([n, r.ready]).then(function (t) {
          const s = e.byteOffset || 0,
            n = e.byteLength || 0,
            o = e.count,
            i = e.byteStride,
            a = new ArrayBuffer(o * i),
            l = new Uint8Array(t[0], s, n);
          return (
            r.decodeGltfBuffer(new Uint8Array(a), o, i, l, e.mode, e.filter), a
          );
        });
      }
      return null;
    }
  }
  const d = "glTF",
    m = 12,
    f = { JSON: 1313821514, BIN: 5130562 };
  class E {
    constructor(e) {
      (this.name = t.KHR_BINARY_GLTF),
        (this.content = null),
        (this.body = null);
      const s = new DataView(e, 0, m);
      if (
        ((this.header = {
          magic: THREE.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
          version: s.getUint32(4, !0),
          length: s.getUint32(8, !0),
        }),
        this.header.magic !== d)
      )
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const n = this.header.length - m,
        r = new DataView(e, m);
      let o = 0;
      for (; o < n; ) {
        const t = r.getUint32(o, !0);
        o += 4;
        const s = r.getUint32(o, !0);
        if (((o += 4), s === f.JSON)) {
          const s = new Uint8Array(e, m + o, t);
          this.content = THREE.LoaderUtils.decodeText(s);
        } else if (s === f.BIN) {
          const s = m + o;
          this.body = e.slice(s, s + t);
        }
        o += t;
      }
      if (null === this.content)
        throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class T {
    constructor(e, s) {
      if (!s)
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      (this.name = t.KHR_DRACO_MESH_COMPRESSION),
        (this.json = e),
        (this.dracoLoader = s),
        this.dracoLoader.preload();
    }
    decodePrimitive(e, t) {
      const s = this.json,
        n = this.dracoLoader,
        r = e.extensions[this.name].bufferView,
        o = e.extensions[this.name].attributes,
        i = {},
        a = {},
        l = {};
      for (const e in o) {
        const t = b[e] || e.toLowerCase();
        i[t] = o[e];
      }
      for (const t in e.attributes) {
        const n = b[t] || t.toLowerCase();
        if (void 0 !== o[t]) {
          const r = s.accessors[e.attributes[t]],
            o = L[r.componentType];
          (l[n] = o), (a[n] = !0 === r.normalized);
        }
      }
      return t.getDependency("bufferView", r).then(function (e) {
        return new Promise(function (t) {
          n.decodeDracoFile(
            e,
            function (e) {
              for (const t in e.attributes) {
                const s = e.attributes[t],
                  n = a[t];
                void 0 !== n && (s.normalized = n);
              }
              t(e);
            },
            i,
            l
          );
        });
      });
    }
  }
  class g {
    constructor() {
      this.name = t.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(e, t) {
      return (
        void 0 !== t.texCoord &&
          console.warn(
            'THREE.GLTFLoader: Custom UV sets in "' +
              this.name +
              '" extension not yet supported.'
          ),
        void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale
          ? e
          : ((e = e.clone()),
            void 0 !== t.offset && e.offset.fromArray(t.offset),
            void 0 !== t.rotation && (e.rotation = t.rotation),
            void 0 !== t.scale && e.repeat.fromArray(t.scale),
            (e.needsUpdate = !0),
            e)
      );
    }
  }
  class R extends THREE.MeshStandardMaterial {
    constructor(e) {
      super(), (this.isGLTFSpecularGlossinessMaterial = !0);
      const t = [
          "#ifdef USE_SPECULARMAP",
          "\tuniform sampler2D specularMap;",
          "#endif",
        ].join("\n"),
        s = [
          "#ifdef USE_GLOSSINESSMAP",
          "\tuniform sampler2D glossinessMap;",
          "#endif",
        ].join("\n"),
        n = [
          "vec3 specularFactor = specular;",
          "#ifdef USE_SPECULARMAP",
          "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
          "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "\tspecularFactor *= texelSpecular.rgb;",
          "#endif",
        ].join("\n"),
        r = [
          "float glossinessFactor = glossiness;",
          "#ifdef USE_GLOSSINESSMAP",
          "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
          "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
          "\tglossinessFactor *= texelGlossiness.a;",
          "#endif",
        ].join("\n"),
        o = [
          "PhysicalMaterial material;",
          "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
          "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
          "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
          "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
          "material.roughness += geometryRoughness;",
          "material.roughness = min( material.roughness, 1.0 );",
          "material.specularColor = specularFactor;",
        ].join("\n"),
        i = {
          specular: { value: new THREE.Color().setHex(16777215) },
          glossiness: { value: 1 },
          specularMap: { value: null },
          glossinessMap: { value: null },
        };
      (this._extraUniforms = i),
        (this.onBeforeCompile = function (e) {
          for (const t in i) e.uniforms[t] = i[t];
          e.fragmentShader = e.fragmentShader
            .replace("uniform float roughness;", "uniform vec3 specular;")
            .replace("uniform float metalness;", "uniform float glossiness;")
            .replace("#include <roughnessmap_pars_fragment>", t)
            .replace("#include <metalnessmap_pars_fragment>", s)
            .replace("#include <roughnessmap_fragment>", n)
            .replace("#include <metalnessmap_fragment>", r)
            .replace("#include <lights_physical_fragment>", o);
        }),
        Object.defineProperties(this, {
          specular: {
            get: function () {
              return i.specular.value;
            },
            set: function (e) {
              i.specular.value = e;
            },
          },
          specularMap: {
            get: function () {
              return i.specularMap.value;
            },
            set: function (e) {
              (i.specularMap.value = e),
                e
                  ? (this.defines.USE_SPECULARMAP = "")
                  : delete this.defines.USE_SPECULARMAP;
            },
          },
          glossiness: {
            get: function () {
              return i.glossiness.value;
            },
            set: function (e) {
              i.glossiness.value = e;
            },
          },
          glossinessMap: {
            get: function () {
              return i.glossinessMap.value;
            },
            set: function (e) {
              (i.glossinessMap.value = e),
                e
                  ? ((this.defines.USE_GLOSSINESSMAP = ""),
                    (this.defines.USE_UV = ""))
                  : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV);
            },
          },
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        (this.specularMap = e.specularMap),
        this.specular.copy(e.specular),
        (this.glossinessMap = e.glossinessMap),
        (this.glossiness = e.glossiness),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this
      );
    }
  }
  class x {
    constructor() {
      (this.name = t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
        (this.specularGlossinessParams = [
          "color",
          "map",
          "lightMap",
          "lightMapIntensity",
          "aoMap",
          "aoMapIntensity",
          "emissive",
          "emissiveIntensity",
          "emissiveMap",
          "bumpMap",
          "bumpScale",
          "normalMap",
          "normalMapType",
          "displacementMap",
          "displacementScale",
          "displacementBias",
          "specularMap",
          "specular",
          "glossinessMap",
          "glossiness",
          "alphaMap",
          "envMap",
          "envMapIntensity",
        ]);
    }
    getMaterialType() {
      return R;
    }
    extendParams(e, t, s) {
      const n = t.extensions[this.name];
      (e.color = new THREE.Color(1, 1, 1)), (e.opacity = 1);
      const r = [];
      if (Array.isArray(n.diffuseFactor)) {
        const t = n.diffuseFactor;
        e.color.fromArray(t), (e.opacity = t[3]);
      }
      if (
        (void 0 !== n.diffuseTexture &&
          r.push(
            s.assignTexture(e, "map", n.diffuseTexture, THREE.sRGBEncoding)
          ),
        (e.emissive = new THREE.Color(0, 0, 0)),
        (e.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1),
        (e.specular = new THREE.Color(1, 1, 1)),
        Array.isArray(n.specularFactor) &&
          e.specular.fromArray(n.specularFactor),
        void 0 !== n.specularGlossinessTexture)
      ) {
        const t = n.specularGlossinessTexture;
        r.push(s.assignTexture(e, "glossinessMap", t)),
          r.push(s.assignTexture(e, "specularMap", t, THREE.sRGBEncoding));
      }
      return Promise.all(r);
    }
    createMaterial(e) {
      const t = new R(e);
      return (
        (t.fog = !0),
        (t.color = e.color),
        (t.map = void 0 === e.map ? null : e.map),
        (t.lightMap = null),
        (t.lightMapIntensity = 1),
        (t.aoMap = void 0 === e.aoMap ? null : e.aoMap),
        (t.aoMapIntensity = 1),
        (t.emissive = e.emissive),
        (t.emissiveIntensity = 1),
        (t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap),
        (t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap),
        (t.bumpScale = 1),
        (t.normalMap = void 0 === e.normalMap ? null : e.normalMap),
        (t.normalMapType = THREE.TangentSpaceNormalMap),
        e.normalScale && (t.normalScale = e.normalScale),
        (t.displacementMap = null),
        (t.displacementScale = 1),
        (t.displacementBias = 0),
        (t.specularMap = void 0 === e.specularMap ? null : e.specularMap),
        (t.specular = e.specular),
        (t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap),
        (t.glossiness = e.glossiness),
        (t.alphaMap = null),
        (t.envMap = void 0 === e.envMap ? null : e.envMap),
        (t.envMapIntensity = 1),
        t
      );
    }
  }
  class M {
    constructor() {
      this.name = t.KHR_MESH_QUANTIZATION;
    }
  }
  class v extends THREE.Interpolant {
    constructor(e, t, s, n) {
      super(e, t, s, n);
    }
    copySampleValue_(e) {
      const t = this.resultBuffer,
        s = this.sampleValues,
        n = this.valueSize,
        r = e * n * 3 + n;
      for (let e = 0; e !== n; e++) t[e] = s[r + e];
      return t;
    }
  }
  (v.prototype.beforeStart_ = v.prototype.copySampleValue_),
    (v.prototype.afterEnd_ = v.prototype.copySampleValue_),
    (v.prototype.interpolate_ = function (e, t, s, n) {
      const r = this.resultBuffer,
        o = this.sampleValues,
        i = this.valueSize,
        a = 2 * i,
        l = 3 * i,
        c = n - t,
        u = (s - t) / c,
        h = u * u,
        p = h * u,
        d = e * l,
        m = d - l,
        f = -2 * p + 3 * h,
        E = p - h,
        T = 1 - f,
        g = E - h + u;
      for (let e = 0; e !== i; e++) {
        const t = o[m + e + i],
          s = o[m + e + a] * c,
          n = o[d + e + i],
          l = o[d + e] * c;
        r[e] = T * t + g * s + f * n + E * l;
      }
      return r;
    });
  const A = new THREE.Quaternion();
  class S extends v {
    interpolate_(e, t, s, n) {
      const r = super.interpolate_(e, t, s, n);
      return A.fromArray(r).normalize().toArray(r), r;
    }
  }
  const _ = {
      FLOAT: 5126,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      LINEAR: 9729,
      REPEAT: 10497,
      SAMPLER_2D: 35678,
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      UNSIGNED_BYTE: 5121,
      UNSIGNED_SHORT: 5123,
    },
    L = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array,
    },
    H = {
      9728: THREE.NearestFilter,
      9729: THREE.LinearFilter,
      9984: THREE.NearestMipmapNearestFilter,
      9985: THREE.LinearMipmapNearestFilter,
      9986: THREE.NearestMipmapLinearFilter,
      9987: THREE.LinearMipmapLinearFilter,
    },
    y = {
      33071: THREE.ClampToEdgeWrapping,
      33648: THREE.MirroredRepeatWrapping,
      10497: THREE.RepeatWrapping,
    },
    w = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
    b = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: "tangent",
      TEXCOORD_0: "uv",
      TEXCOORD_1: "uv2",
      COLOR_0: "color",
      WEIGHTS_0: "skinWeight",
      JOINTS_0: "skinIndex",
    },
    I = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion",
      weights: "morphTargetInfluences",
    },
    P = {
      CUBICSPLINE: void 0,
      LINEAR: THREE.InterpolateLinear,
      STEP: THREE.InterpolateDiscrete,
    },
    C = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
  function N(e, t, s) {
    for (const n in s.extensions)
      void 0 === e[n] &&
        ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
        (t.userData.gltfExtensions[n] = s.extensions[n]));
  }
  function O(e, t) {
    void 0 !== t.extras &&
      ("object" == typeof t.extras
        ? Object.assign(e.userData, t.extras)
        : console.warn(
            "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
          ));
  }
  function F(e, t) {
    if ((e.updateMorphTargets(), void 0 !== t.weights))
      for (let s = 0, n = t.weights.length; s < n; s++)
        e.morphTargetInfluences[s] = t.weights[s];
    if (t.extras && Array.isArray(t.extras.targetNames)) {
      const s = t.extras.targetNames;
      if (e.morphTargetInfluences.length === s.length) {
        e.morphTargetDictionary = {};
        for (let t = 0, n = s.length; t < n; t++)
          e.morphTargetDictionary[s[t]] = t;
      } else
        console.warn(
          "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
        );
    }
  }
  function U(e) {
    const s = e.extensions && e.extensions[t.KHR_DRACO_MESH_COMPRESSION];
    let n;
    return (n = s
      ? "draco:" + s.bufferView + ":" + s.indices + ":" + D(s.attributes)
      : e.indices + ":" + D(e.attributes) + ":" + e.mode);
  }
  function D(e) {
    let t = "";
    const s = Object.keys(e).sort();
    for (let n = 0, r = s.length; n < r; n++) t += s[n] + ":" + e[s[n]] + ";";
    return t;
  }
  function G(e) {
    switch (e) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error(
          "THREE.GLTFLoader: Unsupported normalized accessor component type."
        );
    }
  }
  class k {
    constructor(t = {}, s = {}) {
      (this.json = t),
        (this.extensions = {}),
        (this.plugins = {}),
        (this.options = s),
        (this.cache = new e()),
        (this.associations = new Map()),
        (this.primitiveCache = {}),
        (this.meshCache = { refs: {}, uses: {} }),
        (this.cameraCache = { refs: {}, uses: {} }),
        (this.lightCache = { refs: {}, uses: {} }),
        (this.sourceCache = {}),
        (this.textureCache = {}),
        (this.nodeNamesUsed = {}),
        "undefined" != typeof createImageBitmap &&
        !1 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
          ? (this.textureLoader = new THREE.ImageBitmapLoader(
              this.options.manager
            ))
          : (this.textureLoader = new THREE.TextureLoader(
              this.options.manager
            )),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        (this.fileLoader = new THREE.FileLoader(this.options.manager)),
        this.fileLoader.setResponseType("arraybuffer"),
        "use-credentials" === this.options.crossOrigin &&
          this.fileLoader.setWithCredentials(!0);
    }
    setExtensions(e) {
      this.extensions = e;
    }
    setPlugins(e) {
      this.plugins = e;
    }
    parse(e, t) {
      const s = this,
        n = this.json,
        r = this.extensions;
      this.cache.removeAll(),
        this._invokeAll(function (e) {
          return e._markDefs && e._markDefs();
        }),
        Promise.all(
          this._invokeAll(function (e) {
            return e.beforeRoot && e.beforeRoot();
          })
        )
          .then(function () {
            return Promise.all([
              s.getDependencies("scene"),
              s.getDependencies("animation"),
              s.getDependencies("camera"),
            ]);
          })
          .then(function (t) {
            const o = {
              scene: t[0][n.scene || 0],
              scenes: t[0],
              animations: t[1],
              cameras: t[2],
              asset: n.asset,
              parser: s,
              userData: {},
            };
            N(r, o, n),
              O(o, n),
              Promise.all(
                s._invokeAll(function (e) {
                  return e.afterRoot && e.afterRoot(o);
                })
              ).then(function () {
                e(o);
              });
          })
          .catch(t);
    }
    _markDefs() {
      const e = this.json.nodes || [],
        t = this.json.skins || [],
        s = this.json.meshes || [];
      for (let s = 0, n = t.length; s < n; s++) {
        const n = t[s].joints;
        for (let t = 0, s = n.length; t < s; t++) e[n[t]].isBone = !0;
      }
      for (let t = 0, n = e.length; t < n; t++) {
        const n = e[t];
        void 0 !== n.mesh &&
          (this._addNodeRef(this.meshCache, n.mesh),
          void 0 !== n.skin && (s[n.mesh].isSkinnedMesh = !0)),
          void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera);
      }
    }
    _addNodeRef(e, t) {
      void 0 !== t &&
        (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
    }
    _getNodeRef(e, t, s) {
      if (e.refs[t] <= 1) return s;
      const n = s.clone(),
        r = (e, t) => {
          const s = this.associations.get(e);
          null != s && this.associations.set(t, s);
          for (const [s, n] of e.children.entries()) r(n, t.children[s]);
        };
      return r(s, n), (n.name += "_instance_" + e.uses[t]++), n;
    }
    _invokeOne(e) {
      const t = Object.values(this.plugins);
      t.push(this);
      for (let s = 0; s < t.length; s++) {
        const n = e(t[s]);
        if (n) return n;
      }
      return null;
    }
    _invokeAll(e) {
      const t = Object.values(this.plugins);
      t.unshift(this);
      const s = [];
      for (let n = 0; n < t.length; n++) {
        const r = e(t[n]);
        r && s.push(r);
      }
      return s;
    }
    getDependency(e, t) {
      const s = e + ":" + t;
      let n = this.cache.get(s);
      if (!n) {
        switch (e) {
          case "scene":
            n = this.loadScene(t);
            break;
          case "node":
            n = this.loadNode(t);
            break;
          case "mesh":
            n = this._invokeOne(function (e) {
              return e.loadMesh && e.loadMesh(t);
            });
            break;
          case "accessor":
            n = this.loadAccessor(t);
            break;
          case "bufferView":
            n = this._invokeOne(function (e) {
              return e.loadBufferView && e.loadBufferView(t);
            });
            break;
          case "buffer":
            n = this.loadBuffer(t);
            break;
          case "material":
            n = this._invokeOne(function (e) {
              return e.loadMaterial && e.loadMaterial(t);
            });
            break;
          case "texture":
            n = this._invokeOne(function (e) {
              return e.loadTexture && e.loadTexture(t);
            });
            break;
          case "skin":
            n = this.loadSkin(t);
            break;
          case "animation":
            n = this.loadAnimation(t);
            break;
          case "camera":
            n = this.loadCamera(t);
            break;
          default:
            throw new Error("Unknown type: " + e);
        }
        this.cache.add(s, n);
      }
      return n;
    }
    getDependencies(e) {
      let t = this.cache.get(e);
      if (!t) {
        const s = this,
          n = this.json[e + ("mesh" === e ? "es" : "s")] || [];
        (t = Promise.all(
          n.map(function (t, n) {
            return s.getDependency(e, n);
          })
        )),
          this.cache.add(e, t);
      }
      return t;
    }
    loadBuffer(e) {
      const s = this.json.buffers[e],
        n = this.fileLoader;
      if (s.type && "arraybuffer" !== s.type)
        throw new Error(
          "THREE.GLTFLoader: " + s.type + " buffer type is not supported."
        );
      if (void 0 === s.uri && 0 === e)
        return Promise.resolve(this.extensions[t.KHR_BINARY_GLTF].body);
      const r = this.options;
      return new Promise(function (e, t) {
        n.load(
          THREE.LoaderUtils.resolveURL(s.uri, r.path),
          e,
          void 0,
          function () {
            t(
              new Error(
                'THREE.GLTFLoader: Failed to load buffer "' + s.uri + '".'
              )
            );
          }
        );
      });
    }
    loadBufferView(e) {
      const t = this.json.bufferViews[e];
      return this.getDependency("buffer", t.buffer).then(function (e) {
        const s = t.byteLength || 0,
          n = t.byteOffset || 0;
        return e.slice(n, n + s);
      });
    }
    loadAccessor(e) {
      const t = this,
        s = this.json,
        n = this.json.accessors[e];
      if (void 0 === n.bufferView && void 0 === n.sparse)
        return Promise.resolve(null);
      const r = [];
      return (
        void 0 !== n.bufferView
          ? r.push(this.getDependency("bufferView", n.bufferView))
          : r.push(null),
        void 0 !== n.sparse &&
          (r.push(
            this.getDependency("bufferView", n.sparse.indices.bufferView)
          ),
          r.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
        Promise.all(r).then(function (e) {
          const r = e[0],
            o = w[n.type],
            i = L[n.componentType],
            a = i.BYTES_PER_ELEMENT,
            l = a * o,
            c = n.byteOffset || 0,
            u =
              void 0 !== n.bufferView
                ? s.bufferViews[n.bufferView].byteStride
                : void 0,
            h = !0 === n.normalized;
          let p, d;
          if (u && u !== l) {
            const e = Math.floor(c / u),
              s =
                "InterleavedBuffer:" +
                n.bufferView +
                ":" +
                n.componentType +
                ":" +
                e +
                ":" +
                n.count;
            let l = t.cache.get(s);
            l ||
              ((p = new i(r, e * u, (n.count * u) / a)),
              (l = new THREE.InterleavedBuffer(p, u / a)),
              t.cache.add(s, l)),
              (d = new THREE.InterleavedBufferAttribute(l, o, (c % u) / a, h));
          } else (p = null === r ? new i(n.count * o) : new i(r, c, n.count * o)), (d = new THREE.BufferAttribute(p, o, h));
          if (void 0 !== n.sparse) {
            const t = w.SCALAR,
              s = L[n.sparse.indices.componentType],
              a = n.sparse.indices.byteOffset || 0,
              l = n.sparse.values.byteOffset || 0,
              c = new s(e[1], a, n.sparse.count * t),
              u = new i(e[2], l, n.sparse.count * o);
            null !== r &&
              (d = new THREE.BufferAttribute(
                d.array.slice(),
                d.itemSize,
                d.normalized
              ));
            for (let e = 0, t = c.length; e < t; e++) {
              const t = c[e];
              if (
                (d.setX(t, u[e * o]),
                o >= 2 && d.setY(t, u[e * o + 1]),
                o >= 3 && d.setZ(t, u[e * o + 2]),
                o >= 4 && d.setW(t, u[e * o + 3]),
                o >= 5)
              )
                throw new Error(
                  "THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute."
                );
            }
          }
          return d;
        })
      );
    }
    loadTexture(e) {
      const t = this.json,
        s = this.options,
        n = t.textures[e].source,
        r = t.images[n];
      let o = this.textureLoader;
      if (r.uri) {
        const e = s.manager.getHandler(r.uri);
        null !== e && (o = e);
      }
      return this.loadTextureImage(e, n, o);
    }
    loadTextureImage(e, t, s) {
      const n = this,
        r = this.json,
        o = r.textures[e],
        i = r.images[t],
        a = (i.uri || i.bufferView) + ":" + o.sampler;
      if (this.textureCache[a]) return this.textureCache[a];
      const l = this.loadImageSource(t, s)
        .then(function (t) {
          (t.flipY = !1), o.name && (t.name = o.name);
          const s = (r.samplers || {})[o.sampler] || {};
          return (
            (t.magFilter = H[s.magFilter] || THREE.LinearFilter),
            (t.minFilter = H[s.minFilter] || THREE.LinearMipmapLinearFilter),
            (t.wrapS = y[s.wrapS] || THREE.RepeatWrapping),
            (t.wrapT = y[s.wrapT] || THREE.RepeatWrapping),
            n.associations.set(t, { textures: e }),
            t
          );
        })
        .catch(function () {
          return null;
        });
      return (this.textureCache[a] = l), l;
    }
    loadImageSource(e, t) {
      const s = this,
        n = this.json,
        r = this.options;
      if (void 0 !== this.sourceCache[e])
        return this.sourceCache[e].then((e) => e.clone());
      const o = n.images[e],
        i = self.URL || self.webkitURL;
      let a = o.uri || "",
        l = !1;
      if (void 0 !== o.bufferView)
        a = s.getDependency("bufferView", o.bufferView).then(function (e) {
          l = !0;
          const t = new Blob([e], { type: o.mimeType });
          return (a = i.createObjectURL(t));
        });
      else if (void 0 === o.uri)
        throw new Error(
          "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
        );
      const c = Promise.resolve(a)
        .then(function (e) {
          return new Promise(function (s, n) {
            let o = s;
            !0 === t.isImageBitmapLoader &&
              (o = function (e) {
                const t = new THREE.Texture(e);
                (t.needsUpdate = !0), s(t);
              }),
              t.load(THREE.LoaderUtils.resolveURL(e, r.path), o, void 0, n);
          });
        })
        .then(function (e) {
          var t;
          return (
            !0 === l && i.revokeObjectURL(a),
            (e.userData.mimeType =
              o.mimeType ||
              ((t = o.uri).search(/\.jpe?g($|\?)/i) > 0 ||
              0 === t.search(/^data\:image\/jpeg/)
                ? "image/jpeg"
                : t.search(/\.webp($|\?)/i) > 0 ||
                  0 === t.search(/^data\:image\/webp/)
                ? "image/webp"
                : "image/png")),
            e
          );
        })
        .catch(function (e) {
          throw (
            (console.error("THREE.GLTFLoader: Couldn't load texture", a), e)
          );
        });
      return (this.sourceCache[e] = c), c;
    }
    assignTexture(e, s, n, r) {
      const o = this;
      return this.getDependency("texture", n.index).then(function (i) {
        if (
          (void 0 === n.texCoord ||
            0 == n.texCoord ||
            ("aoMap" === s && 1 == n.texCoord) ||
            console.warn(
              "THREE.GLTFLoader: Custom UV set " +
                n.texCoord +
                " for texture " +
                s +
                " not yet supported."
            ),
          o.extensions[t.KHR_TEXTURE_TRANSFORM])
        ) {
          const e =
            void 0 !== n.extensions
              ? n.extensions[t.KHR_TEXTURE_TRANSFORM]
              : void 0;
          if (e) {
            const s = o.associations.get(i);
            (i = o.extensions[t.KHR_TEXTURE_TRANSFORM].extendTexture(i, e)),
              o.associations.set(i, s);
          }
        }
        return void 0 !== r && (i.encoding = r), (e[s] = i), i;
      });
    }
    assignFinalMaterial(e) {
      const t = e.geometry;
      let s = e.material;
      const n = void 0 === t.attributes.tangent,
        r = void 0 !== t.attributes.color,
        o = void 0 === t.attributes.normal;
      if (e.isPoints) {
        const e = "PointsMaterial:" + s.uuid;
        let t = this.cache.get(e);
        t ||
          ((t = new THREE.PointsMaterial()),
          THREE.Material.prototype.copy.call(t, s),
          t.color.copy(s.color),
          (t.map = s.map),
          (t.sizeAttenuation = !1),
          this.cache.add(e, t)),
          (s = t);
      } else if (e.isLine) {
        const e = "LineBasicMaterial:" + s.uuid;
        let t = this.cache.get(e);
        t ||
          ((t = new THREE.LineBasicMaterial()),
          THREE.Material.prototype.copy.call(t, s),
          t.color.copy(s.color),
          this.cache.add(e, t)),
          (s = t);
      }
      if (n || r || o) {
        let e = "ClonedMaterial:" + s.uuid + ":";
        s.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"),
          n && (e += "derivative-tangents:"),
          r && (e += "vertex-colors:"),
          o && (e += "flat-shading:");
        let t = this.cache.get(e);
        t ||
          ((t = s.clone()),
          r && (t.vertexColors = !0),
          o && (t.flatShading = !0),
          n &&
            (t.normalScale && (t.normalScale.y *= -1),
            t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
          this.cache.add(e, t),
          this.associations.set(t, this.associations.get(s))),
          (s = t);
      }
      s.aoMap &&
        void 0 === t.attributes.uv2 &&
        void 0 !== t.attributes.uv &&
        t.setAttribute("uv2", t.attributes.uv),
        (e.material = s);
    }
    getMaterialType() {
      return THREE.MeshStandardMaterial;
    }
    loadMaterial(e) {
      const s = this,
        n = this.json,
        r = this.extensions,
        o = n.materials[e];
      let i;
      const a = {},
        l = o.extensions || {},
        c = [];
      if (l[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        const e = r[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        (i = e.getMaterialType()), c.push(e.extendParams(a, o, s));
      } else if (l[t.KHR_MATERIALS_UNLIT]) {
        const e = r[t.KHR_MATERIALS_UNLIT];
        (i = e.getMaterialType()), c.push(e.extendParams(a, o, s));
      } else {
        const t = o.pbrMetallicRoughness || {};
        if (
          ((a.color = new THREE.Color(1, 1, 1)),
          (a.opacity = 1),
          Array.isArray(t.baseColorFactor))
        ) {
          const e = t.baseColorFactor;
          a.color.fromArray(e), (a.opacity = e[3]);
        }
        void 0 !== t.baseColorTexture &&
          c.push(
            s.assignTexture(a, "map", t.baseColorTexture, THREE.sRGBEncoding)
          ),
          (a.metalness = void 0 !== t.metallicFactor ? t.metallicFactor : 1),
          (a.roughness = void 0 !== t.roughnessFactor ? t.roughnessFactor : 1),
          void 0 !== t.metallicRoughnessTexture &&
            (c.push(
              s.assignTexture(a, "metalnessMap", t.metallicRoughnessTexture)
            ),
            c.push(
              s.assignTexture(a, "roughnessMap", t.metallicRoughnessTexture)
            )),
          (i = this._invokeOne(function (t) {
            return t.getMaterialType && t.getMaterialType(e);
          })),
          c.push(
            Promise.all(
              this._invokeAll(function (t) {
                return t.extendMaterialParams && t.extendMaterialParams(e, a);
              })
            )
          );
      }
      !0 === o.doubleSided && (a.side = THREE.DoubleSide);
      const u = o.alphaMode || C.OPAQUE;
      if (
        (u === C.BLEND
          ? ((a.transparent = !0), (a.depthWrite = !1))
          : ((a.transparent = !1),
            u === C.MASK &&
              (a.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : 0.5)),
        void 0 !== o.normalTexture &&
          i !== THREE.MeshBasicMaterial &&
          (c.push(s.assignTexture(a, "normalMap", o.normalTexture)),
          (a.normalScale = new THREE.Vector2(1, 1)),
          void 0 !== o.normalTexture.scale))
      ) {
        const e = o.normalTexture.scale;
        a.normalScale.set(e, e);
      }
      return (
        void 0 !== o.occlusionTexture &&
          i !== THREE.MeshBasicMaterial &&
          (c.push(s.assignTexture(a, "aoMap", o.occlusionTexture)),
          void 0 !== o.occlusionTexture.strength &&
            (a.aoMapIntensity = o.occlusionTexture.strength)),
        void 0 !== o.emissiveFactor &&
          i !== THREE.MeshBasicMaterial &&
          (a.emissive = new THREE.Color().fromArray(o.emissiveFactor)),
        void 0 !== o.emissiveTexture &&
          i !== THREE.MeshBasicMaterial &&
          c.push(
            s.assignTexture(
              a,
              "emissiveMap",
              o.emissiveTexture,
              THREE.sRGBEncoding
            )
          ),
        Promise.all(c).then(function () {
          let n;
          return (
            (n =
              i === R
                ? r[t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a)
                : new i(a)),
            o.name && (n.name = o.name),
            O(n, o),
            s.associations.set(n, { materials: e }),
            o.extensions && N(r, n, o),
            n
          );
        })
      );
    }
    createUniqueName(e) {
      const t = THREE.PropertyBinding.sanitizeNodeName(e || "");
      let s = t;
      for (let e = 1; this.nodeNamesUsed[s]; ++e) s = t + "_" + e;
      return (this.nodeNamesUsed[s] = !0), s;
    }
    loadGeometries(e) {
      const s = this,
        n = this.extensions,
        r = this.primitiveCache;
      function o(e) {
        return n[t.KHR_DRACO_MESH_COMPRESSION]
          .decodePrimitive(e, s)
          .then(function (t) {
            return K(t, e, s);
          });
      }
      const i = [];
      for (let n = 0, a = e.length; n < a; n++) {
        const a = e[n],
          l = U(a),
          c = r[l];
        if (c) i.push(c.promise);
        else {
          let e;
          (e =
            a.extensions && a.extensions[t.KHR_DRACO_MESH_COMPRESSION]
              ? o(a)
              : K(new THREE.BufferGeometry(), a, s)),
            (r[l] = { primitive: a, promise: e }),
            i.push(e);
        }
      }
      return Promise.all(i);
    }
    loadMesh(e) {
      const t = this,
        s = this.json,
        n = this.extensions,
        r = s.meshes[e],
        o = r.primitives,
        i = [];
      for (let e = 0, t = o.length; e < t; e++) {
        const t =
          void 0 === o[e].material
            ? (void 0 === (a = this.cache).DefaultMaterial &&
                (a.DefaultMaterial = new THREE.MeshStandardMaterial({
                  color: 16777215,
                  emissive: 0,
                  metalness: 1,
                  roughness: 1,
                  transparent: !1,
                  depthTest: !0,
                  side: THREE.FrontSide,
                })),
              a.DefaultMaterial)
            : this.getDependency("material", o[e].material);
        i.push(t);
      }
      var a;
      return (
        i.push(t.loadGeometries(o)),
        Promise.all(i).then(function (s) {
          const i = s.slice(0, s.length - 1),
            a = s[s.length - 1],
            l = [];
          for (let s = 0, c = a.length; s < c; s++) {
            const c = a[s],
              u = o[s];
            let h;
            const p = i[s];
            if (
              u.mode === _.TRIANGLES ||
              u.mode === _.TRIANGLE_STRIP ||
              u.mode === _.TRIANGLE_FAN ||
              void 0 === u.mode
            )
              !0 !==
                (h =
                  !0 === r.isSkinnedMesh
                    ? new THREE.SkinnedMesh(c, p)
                    : new THREE.Mesh(c, p)).isSkinnedMesh ||
                h.geometry.attributes.skinWeight.normalized ||
                h.normalizeSkinWeights(),
                u.mode === _.TRIANGLE_STRIP
                  ? (h.geometry = j(h.geometry, THREE.TriangleStripDrawMode))
                  : u.mode === _.TRIANGLE_FAN &&
                    (h.geometry = j(h.geometry, THREE.TriangleFanDrawMode));
            else if (u.mode === _.LINES) h = new THREE.LineSegments(c, p);
            else if (u.mode === _.LINE_STRIP) h = new THREE.Line(c, p);
            else if (u.mode === _.LINE_LOOP) h = new THREE.LineLoop(c, p);
            else {
              if (u.mode !== _.POINTS)
                throw new Error(
                  "THREE.GLTFLoader: Primitive mode unsupported: " + u.mode
                );
              h = new THREE.Points(c, p);
            }
            Object.keys(h.geometry.morphAttributes).length > 0 && F(h, r),
              (h.name = t.createUniqueName(r.name || "mesh_" + e)),
              O(h, r),
              u.extensions && N(n, h, u),
              t.assignFinalMaterial(h),
              l.push(h);
          }
          for (let s = 0, n = l.length; s < n; s++)
            t.associations.set(l[s], { meshes: e, primitives: s });
          if (1 === l.length) return l[0];
          const c = new THREE.Group();
          t.associations.set(c, { meshes: e });
          for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
          return c;
        })
      );
    }
    loadCamera(e) {
      let t;
      const s = this.json.cameras[e],
        n = s[s.type];
      if (n)
        return (
          "perspective" === s.type
            ? (t = new THREE.PerspectiveCamera(
                THREE.MathUtils.radToDeg(n.yfov),
                n.aspectRatio || 1,
                n.znear || 1,
                n.zfar || 2e6
              ))
            : "orthographic" === s.type &&
              (t = new THREE.OrthographicCamera(
                -n.xmag,
                n.xmag,
                n.ymag,
                -n.ymag,
                n.znear,
                n.zfar
              )),
          s.name && (t.name = this.createUniqueName(s.name)),
          O(t, s),
          Promise.resolve(t)
        );
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
    loadSkin(e) {
      const t = this.json.skins[e],
        s = { joints: t.joints };
      return void 0 === t.inverseBindMatrices
        ? Promise.resolve(s)
        : this.getDependency("accessor", t.inverseBindMatrices).then(function (
            e
          ) {
            return (s.inverseBindMatrices = e), s;
          });
    }
    loadAnimation(e) {
      const t = this.json.animations[e],
        s = [],
        n = [],
        r = [],
        o = [],
        i = [];
      for (let e = 0, a = t.channels.length; e < a; e++) {
        const a = t.channels[e],
          l = t.samplers[a.sampler],
          c = a.target,
          u = void 0 !== c.node ? c.node : c.id,
          h = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
          p = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
        s.push(this.getDependency("node", u)),
          n.push(this.getDependency("accessor", h)),
          r.push(this.getDependency("accessor", p)),
          o.push(l),
          i.push(c);
      }
      return Promise.all([
        Promise.all(s),
        Promise.all(n),
        Promise.all(r),
        Promise.all(o),
        Promise.all(i),
      ]).then(function (s) {
        const n = s[0],
          r = s[1],
          o = s[2],
          i = s[3],
          a = s[4],
          l = [];
        for (let e = 0, t = n.length; e < t; e++) {
          const t = n[e],
            s = r[e],
            c = o[e],
            u = i[e],
            h = a[e];
          if (void 0 === t) continue;
          let p;
          switch ((t.updateMatrix(), (t.matrixAutoUpdate = !0), I[h.path])) {
            case I.weights:
              p = THREE.NumberKeyframeTrack;
              break;
            case I.rotation:
              p = THREE.QuaternionKeyframeTrack;
              break;
            case I.position:
            case I.scale:
            default:
              p = THREE.VectorKeyframeTrack;
          }
          const d = t.name ? t.name : t.uuid,
            m =
              void 0 !== u.interpolation
                ? P[u.interpolation]
                : THREE.InterpolateLinear,
            f = [];
          I[h.path] === I.weights
            ? t.traverse(function (e) {
                e.morphTargetInfluences && f.push(e.name ? e.name : e.uuid);
              })
            : f.push(d);
          let E = c.array;
          if (c.normalized) {
            const e = G(E.constructor),
              t = new Float32Array(E.length);
            for (let s = 0, n = E.length; s < n; s++) t[s] = E[s] * e;
            E = t;
          }
          for (let e = 0, t = f.length; e < t; e++) {
            const t = new p(f[e] + "." + I[h.path], s.array, E, m);
            "CUBICSPLINE" === u.interpolation &&
              ((t.createInterpolant = function (e) {
                return new (
                  this instanceof THREE.QuaternionKeyframeTrack ? S : v
                )(this.times, this.values, this.getValueSize() / 3, e);
              }),
              (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                !0)),
              l.push(t);
          }
        }
        const c = t.name ? t.name : "animation_" + e;
        return new THREE.AnimationClip(c, void 0, l);
      });
    }
    createNodeMesh(e) {
      const t = this.json,
        s = this,
        n = t.nodes[e];
      return void 0 === n.mesh
        ? null
        : s.getDependency("mesh", n.mesh).then(function (e) {
            const t = s._getNodeRef(s.meshCache, n.mesh, e);
            return (
              void 0 !== n.weights &&
                t.traverse(function (e) {
                  if (e.isMesh)
                    for (let t = 0, s = n.weights.length; t < s; t++)
                      e.morphTargetInfluences[t] = n.weights[t];
                }),
              t
            );
          });
    }
    loadNode(e) {
      const t = this.json,
        s = this.extensions,
        n = this,
        r = t.nodes[e],
        o = r.name ? n.createUniqueName(r.name) : "";
      return (function () {
        const t = [],
          s = n._invokeOne(function (t) {
            return t.createNodeMesh && t.createNodeMesh(e);
          });
        return (
          s && t.push(s),
          void 0 !== r.camera &&
            t.push(
              n.getDependency("camera", r.camera).then(function (e) {
                return n._getNodeRef(n.cameraCache, r.camera, e);
              })
            ),
          n
            ._invokeAll(function (t) {
              return t.createNodeAttachment && t.createNodeAttachment(e);
            })
            .forEach(function (e) {
              t.push(e);
            }),
          Promise.all(t)
        );
      })().then(function (t) {
        let i;
        if (
          (i =
            !0 === r.isBone
              ? new THREE.Bone()
              : t.length > 1
              ? new THREE.Group()
              : 1 === t.length
              ? t[0]
              : new THREE.Object3D()) !== t[0]
        )
          for (let e = 0, s = t.length; e < s; e++) i.add(t[e]);
        if (
          (r.name && ((i.userData.name = r.name), (i.name = o)),
          O(i, r),
          r.extensions && N(s, i, r),
          void 0 !== r.matrix)
        ) {
          const e = new THREE.Matrix4();
          e.fromArray(r.matrix), i.applyMatrix4(e);
        } else void 0 !== r.translation && i.position.fromArray(r.translation), void 0 !== r.rotation && i.quaternion.fromArray(r.rotation), void 0 !== r.scale && i.scale.fromArray(r.scale);
        return (
          n.associations.has(i) || n.associations.set(i, {}),
          (n.associations.get(i).nodes = e),
          i
        );
      });
    }
    loadScene(e) {
      const t = this.json,
        s = this.extensions,
        n = this.json.scenes[e],
        r = this,
        o = new THREE.Group();
      n.name && (o.name = r.createUniqueName(n.name)),
        O(o, n),
        n.extensions && N(s, o, n);
      const i = n.nodes || [],
        a = [];
      for (let e = 0, s = i.length; e < s; e++) a.push(B(i[e], o, t, r));
      return Promise.all(a).then(function () {
        return (
          (r.associations = ((e) => {
            const t = new Map();
            for (const [e, s] of r.associations)
              (e instanceof THREE.Material || e instanceof THREE.Texture) &&
                t.set(e, s);
            return (
              e.traverse((e) => {
                const s = r.associations.get(e);
                null != s && t.set(e, s);
              }),
              t
            );
          })(o)),
          o
        );
      });
    }
  }
  function B(e, t, s, n) {
    const r = s.nodes[e];
    return n
      .getDependency("node", e)
      .then(function (e) {
        if (void 0 === r.skin) return e;
        let t;
        return n
          .getDependency("skin", r.skin)
          .then(function (e) {
            const s = [];
            for (let r = 0, o = (t = e).joints.length; r < o; r++)
              s.push(n.getDependency("node", t.joints[r]));
            return Promise.all(s);
          })
          .then(function (s) {
            return (
              e.traverse(function (e) {
                if (!e.isMesh) return;
                const n = [],
                  r = [];
                for (let e = 0, o = s.length; e < o; e++) {
                  const o = s[e];
                  if (o) {
                    n.push(o);
                    const s = new THREE.Matrix4();
                    void 0 !== t.inverseBindMatrices &&
                      s.fromArray(t.inverseBindMatrices.array, 16 * e),
                      r.push(s);
                  } else
                    console.warn(
                      'THREE.GLTFLoader: Joint "%s" could not be found.',
                      t.joints[e]
                    );
                }
                e.bind(new THREE.Skeleton(n, r), e.matrixWorld);
              }),
              e
            );
          });
      })
      .then(function (e) {
        t.add(e);
        const o = [];
        if (r.children) {
          const t = r.children;
          for (let r = 0, i = t.length; r < i; r++) {
            const i = t[r];
            o.push(B(i, e, s, n));
          }
        }
        return Promise.all(o);
      });
  }
  function K(e, t, s) {
    const n = t.attributes,
      r = [];
    function o(t, n) {
      return s.getDependency("accessor", t).then(function (t) {
        e.setAttribute(n, t);
      });
    }
    for (const t in n) {
      const s = b[t] || t.toLowerCase();
      s in e.attributes || r.push(o(n[t], s));
    }
    if (void 0 !== t.indices && !e.index) {
      const n = s.getDependency("accessor", t.indices).then(function (t) {
        e.setIndex(t);
      });
      r.push(n);
    }
    return (
      O(e, t),
      (function (e, t, s) {
        const n = t.attributes,
          r = new THREE.Box3();
        if (void 0 === n.POSITION) return;
        {
          const e = s.json.accessors[n.POSITION],
            t = e.min,
            o = e.max;
          if (void 0 === t || void 0 === o)
            return void console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
          if (
            (r.set(
              new THREE.Vector3(t[0], t[1], t[2]),
              new THREE.Vector3(o[0], o[1], o[2])
            ),
            e.normalized)
          ) {
            const t = G(L[e.componentType]);
            r.min.multiplyScalar(t), r.max.multiplyScalar(t);
          }
        }
        const o = t.targets;
        if (void 0 !== o) {
          const e = new THREE.Vector3(),
            t = new THREE.Vector3();
          for (let n = 0, r = o.length; n < r; n++) {
            const r = o[n];
            if (void 0 !== r.POSITION) {
              const n = s.json.accessors[r.POSITION],
                o = n.min,
                i = n.max;
              if (void 0 !== o && void 0 !== i) {
                if (
                  (t.setX(Math.max(Math.abs(o[0]), Math.abs(i[0]))),
                  t.setY(Math.max(Math.abs(o[1]), Math.abs(i[1]))),
                  t.setZ(Math.max(Math.abs(o[2]), Math.abs(i[2]))),
                  n.normalized)
                ) {
                  const e = G(L[n.componentType]);
                  t.multiplyScalar(e);
                }
                e.max(t);
              } else
                console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
            }
          }
          r.expandByVector(e);
        }
        e.boundingBox = r;
        const i = new THREE.Sphere();
        r.getCenter(i.center),
          (i.radius = r.min.distanceTo(r.max) / 2),
          (e.boundingSphere = i);
      })(e, t, s),
      Promise.all(r).then(function () {
        return void 0 !== t.targets
          ? (function (e, t, s) {
              let n = !1,
                r = !1,
                o = !1;
              for (let e = 0, s = t.length; e < s; e++) {
                const s = t[e];
                if (
                  (void 0 !== s.POSITION && (n = !0),
                  void 0 !== s.NORMAL && (r = !0),
                  void 0 !== s.COLOR_0 && (o = !0),
                  n && r && o)
                )
                  break;
              }
              if (!n && !r && !o) return Promise.resolve(e);
              const i = [],
                a = [],
                l = [];
              for (let c = 0, u = t.length; c < u; c++) {
                const u = t[c];
                if (n) {
                  const t =
                    void 0 !== u.POSITION
                      ? s.getDependency("accessor", u.POSITION)
                      : e.attributes.position;
                  i.push(t);
                }
                if (r) {
                  const t =
                    void 0 !== u.NORMAL
                      ? s.getDependency("accessor", u.NORMAL)
                      : e.attributes.normal;
                  a.push(t);
                }
                if (o) {
                  const t =
                    void 0 !== u.COLOR_0
                      ? s.getDependency("accessor", u.COLOR_0)
                      : e.attributes.color;
                  l.push(t);
                }
              }
              return Promise.all([
                Promise.all(i),
                Promise.all(a),
                Promise.all(l),
              ]).then(function (t) {
                const s = t[0],
                  i = t[1],
                  a = t[2];
                return (
                  n && (e.morphAttributes.position = s),
                  r && (e.morphAttributes.normal = i),
                  o && (e.morphAttributes.color = a),
                  (e.morphTargetsRelative = !0),
                  e
                );
              });
            })(e, t.targets, s)
          : e;
      })
    );
  }
  function j(e, t) {
    let s = e.getIndex();
    if (null === s) {
      const t = [],
        n = e.getAttribute("position");
      if (void 0 === n)
        return (
          console.error(
            "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          e
        );
      for (let e = 0; e < n.count; e++) t.push(e);
      e.setIndex(t), (s = e.getIndex());
    }
    const n = s.count - 2,
      r = [];
    if (t === THREE.TriangleFanDrawMode)
      for (let e = 1; e <= n; e++)
        r.push(s.getX(0)), r.push(s.getX(e)), r.push(s.getX(e + 1));
    else
      for (let e = 0; e < n; e++)
        e % 2 == 0
          ? (r.push(s.getX(e)), r.push(s.getX(e + 1)), r.push(s.getX(e + 2)))
          : (r.push(s.getX(e + 2)), r.push(s.getX(e + 1)), r.push(s.getX(e)));
    r.length / 3 !== n &&
      console.error(
        "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const o = e.clone();
    return o.setIndex(r), o;
  }
  THREE.GLTFLoader = class extends THREE.Loader {
    constructor(e) {
      super(e),
        (this.dracoLoader = null),
        (this.ktx2Loader = null),
        (this.meshoptDecoder = null),
        (this.pluginCallbacks = []),
        this.register(function (e) {
          return new r(e);
        }),
        this.register(function (e) {
          return new u(e);
        }),
        this.register(function (e) {
          return new h(e);
        }),
        this.register(function (e) {
          return new o(e);
        }),
        this.register(function (e) {
          return new i(e);
        }),
        this.register(function (e) {
          return new a(e);
        }),
        this.register(function (e) {
          return new l(e);
        }),
        this.register(function (e) {
          return new c(e);
        }),
        this.register(function (e) {
          return new s(e);
        }),
        this.register(function (e) {
          return new p(e);
        });
    }
    load(e, t, s, n) {
      const r = this;
      let o;
      (o =
        "" !== this.resourcePath
          ? this.resourcePath
          : "" !== this.path
          ? this.path
          : THREE.LoaderUtils.extractUrlBase(e)),
        this.manager.itemStart(e);
      const i = function (t) {
          n ? n(t) : console.error(t),
            r.manager.itemError(e),
            r.manager.itemEnd(e);
        },
        a = new THREE.FileLoader(this.manager);
      a.setPath(this.path),
        a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials),
        a.load(
          e,
          function (s) {
            try {
              r.parse(
                s,
                o,
                function (s) {
                  t(s), r.manager.itemEnd(e);
                },
                i
              );
            } catch (e) {
              i(e);
            }
          },
          s,
          i
        );
    }
    setDRACOLoader(e) {
      return (this.dracoLoader = e), this;
    }
    setDDSLoader() {
      throw new Error(
        'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
      );
    }
    setKTX2Loader(e) {
      return (this.ktx2Loader = e), this;
    }
    setMeshoptDecoder(e) {
      return (this.meshoptDecoder = e), this;
    }
    register(e) {
      return (
        -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
        this
      );
    }
    unregister(e) {
      return (
        -1 !== this.pluginCallbacks.indexOf(e) &&
          this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
      );
    }
    parse(e, s, r, o) {
      let i;
      const a = {},
        l = {};
      if ("string" == typeof e) i = e;
      else if (THREE.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === d) {
        try {
          a[t.KHR_BINARY_GLTF] = new E(e);
        } catch (e) {
          return void (o && o(e));
        }
        i = a[t.KHR_BINARY_GLTF].content;
      } else i = THREE.LoaderUtils.decodeText(new Uint8Array(e));
      const c = JSON.parse(i);
      if (void 0 === c.asset || c.asset.version[0] < 2)
        return void (
          o &&
          o(
            new Error(
              "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
            )
          )
        );
      const u = new k(c, {
        path: s || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder,
      });
      u.fileLoader.setRequestHeader(this.requestHeader);
      for (let e = 0; e < this.pluginCallbacks.length; e++) {
        const t = this.pluginCallbacks[e](u);
        (l[t.name] = t), (a[t.name] = !0);
      }
      if (c.extensionsUsed)
        for (let e = 0; e < c.extensionsUsed.length; ++e) {
          const s = c.extensionsUsed[e],
            r = c.extensionsRequired || [];
          switch (s) {
            case t.KHR_MATERIALS_UNLIT:
              a[s] = new n();
              break;
            case t.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              a[s] = new x();
              break;
            case t.KHR_DRACO_MESH_COMPRESSION:
              a[s] = new T(c, this.dracoLoader);
              break;
            case t.KHR_TEXTURE_TRANSFORM:
              a[s] = new g();
              break;
            case t.KHR_MESH_QUANTIZATION:
              a[s] = new M();
              break;
            default:
              r.indexOf(s) >= 0 &&
                void 0 === l[s] &&
                console.warn(
                  'THREE.GLTFLoader: Unknown extension "' + s + '".'
                );
          }
        }
      u.setExtensions(a), u.setPlugins(l), u.parse(r, o);
    }
    parseAsync(e, t) {
      const s = this;
      return new Promise(function (n, r) {
        s.parse(e, t, n, r);
      });
    }
  };
})();
